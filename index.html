<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bart's Lobotomy</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; color: #FFD90F;
        }
        
        #ui {
            position: absolute; top: 20px; width: 100%; text-align: center; color: #FFD90F; 
            font-size: 24px; pointer-events: none; z-index: 5; text-shadow: 2px 2px #f00;
        }

        #leaderboard {
            margin-top: 20px; padding: 10px; border: 2px solid #FFD90F;
            width: 300px; text-align: left; background: rgba(255,0,0,0.1);
        }

        #qte {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 180px; color: #fff; display: none; font-weight: bold; z-index: 10;
            text-shadow: 0 0 50px #ff0000;
        }

        button {
            padding: 15px 30px; font-size: 24px; background: #FFD90F; border: none;
            cursor: pointer; font-family: 'Courier New', Courier, monospace; font-weight: bold;
            box-shadow: 5px 5px 0 #ff0000; margin: 10px;
        }

        button:hover { background: #fff; }
        .inverted { filter: invert(100%) contrast(120%); }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>BART'S LOBOTOMY</h1>
        <h3> style="margin:0;">(Beta 0.1)</h3>
        <h2 style="margin:0;">A Game By Max And Aiden </h2>
        
        <div id="leaderboard">
            <div style="text-align:center; text-decoration: underline; margin-bottom:5px;">TOP BRAINS</div>
            <div id="highscore-list">1. No Data - 000</div>
        </div>

        <p style="color: #fff; margin-top:20px;">SPACE: FLIP | CLICK: FIRE | SHIFT: BOOST</p>
        <button onclick="startGame()">Start Game</button>
    </div>

    <div id="ui">SCORE: 0 | BRAIN STATUS: STABLE</div>
    <div id="qte">!</div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

<script type="module">
import * as THREE from 'three';

// --- HIGHSCORE SYSTEM ---
function getHighscores() {
    const scores = localStorage.getItem('bart_scores');
    return scores ? JSON.parse(scores) : [];
}

function saveHighscore(name, score) {
    let scores = getHighscores();
    scores.push({name, score});
    scores.sort((a, b) => b.score - a.score);
    scores = scores.slice(0, 5); // Keep top 5
    localStorage.setItem('bart_scores', JSON.stringify(scores));
}

function updateLeaderboardUI() {
    const scores = getHighscores();
    const list = document.getElementById('highscore-list');
    if (scores.length === 0) {
        list.innerHTML = "1. Empty Slot - 000";
        return;
    }
    list.innerHTML = scores.map((s, i) => `${i+1}. ${s.name.substring(0,8)} - ${s.score}`).join('<br>');
}

updateLeaderboardUI();

// --- GAME LOGIC ---
let gameActive = false;
let score = 0, speed = 0.4, velocity = 0, gravity = -0.015;
let qteActive = false, currentQTEKey = '';
const obstacles = [], bullets = [];

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const sun = new THREE.PointLight(0xffffff, 100, 100);
sun.position.set(0, 0, 10);
scene.add(sun, new THREE.AmbientLight(0x404040));

const bartMat = new THREE.MeshStandardMaterial({color: 0xFFD90F, roughness: 0});
const fleshMat = new THREE.MeshStandardMaterial({color: 0x882222, metalness: 0.5});

const bart = new THREE.Group();
bart.add(new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 1), bartMat));
bart.add(new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.1, 0.8), new THREE.MeshStandardMaterial({color: 0x32CD32})));
bart.position.x = -5;
scene.add(bart);

function playScream() {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const out = ctx.destination;
    const carrier = ctx.createOscillator();
    const modulator = ctx.createOscillator();
    const modGain = ctx.createGain();
    const mainGain = ctx.createGain();
    const distortion = ctx.createWaveShaper();

    function makeDist(amount) {
        let n = 44100, curve = new Float32Array(n), deg = Math.PI / 180, i = 0, x;
        for ( ; i < n; ++i ) {
            x = i * 2 / n - 1;
            curve[i] = (3 + amount) * x * 20 * deg / (Math.PI + amount * Math.abs(x));
        }
        return curve;
    }

    distortion.curve = makeDist(600);
    carrier.type = 'sawtooth';
    modulator.type = 'square';
    carrier.frequency.setValueAtTime(400, ctx.currentTime);
    carrier.frequency.exponentialRampToValueAtTime(30, ctx.currentTime + 1.2);
    modulator.frequency.setValueAtTime(60, ctx.currentTime);
    modGain.gain.setValueAtTime(1200, ctx.currentTime);
    mainGain.gain.setValueAtTime(2.0, ctx.currentTime);
    mainGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 1.2);

    modulator.connect(modGain);
    modGain.connect(carrier.frequency);
    carrier.connect(distortion);
    distortion.connect(mainGain);
    mainGain.connect(out);
    carrier.start(); modulator.start();
}

window.startGame = () => {
    document.getElementById('overlay').style.display = 'none';
    gameActive = true;
    animate();
};

function triggerQTE() {
    if (qteActive || !gameActive) return;
    qteActive = true;
    currentQTEKey = ['W','A','S','D','X'][Math.floor(Math.random()*5)];
    const el = document.getElementById('qte');
    el.innerText = currentQTEKey;
    el.style.display = 'block';
    setTimeout(() => { if(qteActive) endGame(); }, 800);
}

window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') gravity *= -1;
    if (qteActive && e.key.toUpperCase() === currentQTEKey) {
        qteActive = false;
        document.getElementById('qte').style.display = 'none';
        score += 150;
    }
});

window.addEventListener('mousedown', () => {
    if (!gameActive) return;
    const b = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color: 0x00ffff}));
    b.position.copy(bart.position);
    scene.add(b);
    bullets.push(b);
});

function animate() {
    if (!gameActive) return;
    requestAnimationFrame(animate);

    if (Math.random() < 0.006) triggerQTE();
    if (Math.random() < 0.01) {
        document.body.classList.add('inverted');
        setTimeout(() => document.body.classList.remove('inverted'), 80);
    }

    velocity += gravity;
    bart.position.y += velocity;
    bart.position.y = Math.max(-4.5, Math.min(4.5, bart.position.y));

    bullets.forEach((b, bi) => {
        b.position.x += 1;
        obstacles.forEach((o, oi) => {
            if (b.position.distanceTo(o.position) < 2) {
                scene.remove(o, b);
                obstacles.splice(oi, 1);
                bullets.splice(bi, 1);
            }
        });
    });

    obstacles.forEach((o, i) => {
        o.position.x -= speed;
        if (bart.position.distanceTo(o.position) < 1.6) endGame();
        if (o.position.x < -20) { scene.remove(o); obstacles.splice(i, 1); score += 10; }
    });

    if (Math.random() < 0.04) {
        const obs = new THREE.Mesh(new THREE.IcosahedronGeometry(2, 0), fleshMat);
        obs.position.set(25, (Math.random() * 8) - 4, 0);
        scene.add(obs);
        obstacles.push(obs);
    }

    document.getElementById('ui').innerText = `SCORE: ${score} | BRAIN STATUS: ${score > 1000 ? 'DECAYING' : 'STABLE'}`;
    renderer.render(scene, camera);
}

function endGame() {
    gameActive = false;
    document.getElementById('qte').style.display = 'none';
    playScream();

    const homer = new THREE.Mesh(new THREE.IcosahedronGeometry(5, 1), new THREE.MeshBasicMaterial({color: 0xFFD90F, wireframe: true}));
    homer.position.set(0, 0, 5);
    scene.add(homer);

    let z = 5;
    const scare = setInterval(() => {
        z += 1.5;
        homer.position.z = z;
        homer.rotation.y += 0.4;
        if (z > 20) {
            clearInterval(scare);
            const name = prompt("SURGERY FAILED. ENTER YOUR NAME:", "PATIENT");
            if (name) saveHighscore(name, score);
            location.reload();
        }
        renderer.render(scene, camera);
    }, 16);
}

camera.position.z = 12;

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
